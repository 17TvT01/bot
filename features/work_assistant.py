import json
import os
import time
import threading
import datetime
from typing import Dict, List, Optional
import random

class TaskManager:
    def __init__(self):
        self.tasks_file = "tasks.json"
        self.tasks = self._load_tasks()
        
    def _load_tasks(self) -> List[Dict]:
        """Load tasks from file."""
        if os.path.exists(self.tasks_file):
            try:
                with open(self.tasks_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                return []
        return []
    
    def _save_tasks(self):
        """Save tasks to file."""
        with open(self.tasks_file, 'w', encoding='utf-8') as f:
            json.dump(self.tasks, f, ensure_ascii=False, indent=2)
    
    def add_task(self, task_description: str, priority: str = "medium") -> str:
        """Add a new task."""
        task = {
            "id": len(self.tasks) + 1,
            "description": task_description,
            "priority": priority,
            "completed": False,
            "created_at": datetime.datetime.now().isoformat(),
            "completed_at": None
        }
        self.tasks.append(task)
        self._save_tasks()
        return f"ƒê√£ th√™m task: {task_description} (∆Øu ti√™n: {priority})"
    
    def list_tasks(self, show_completed: bool = False) -> str:
        """List all tasks."""
        if not self.tasks:
            return "Kh√¥ng c√≥ task n√†o."
        
        filtered_tasks = [t for t in self.tasks if show_completed or not t['completed']]
        
        if not filtered_tasks:
            return "Kh√¥ng c√≥ task ƒëang ch·ªù."
        
        result = "üìã Danh s√°ch task:\n"
        for task in filtered_tasks:
            status = "‚úÖ" if task['completed'] else "‚è≥"
            priority_emoji = {"high": "üî¥", "medium": "üü°", "low": "üü¢"}.get(task['priority'], "‚ö™")
            result += f"{status} {priority_emoji} {task['id']}. {task['description']}\n"
        
        return result
    
    def complete_task(self, task_id: int) -> str:
        """Mark a task as completed."""
        for task in self.tasks:
            if task['id'] == task_id:
                task['completed'] = True
                task['completed_at'] = datetime.datetime.now().isoformat()
                self._save_tasks()
                return f"‚úÖ ƒê√£ ho√†n th√†nh task: {task['description']}"
        return "‚ùå Kh√¥ng t√¨m th·∫•y task v·ªõi ID n√†y."
    
    def clear_completed(self) -> str:
        """Remove all completed tasks."""
        completed_count = sum(1 for t in self.tasks if t['completed'])
        self.tasks = [t for t in self.tasks if not t['completed']]
        self._save_tasks()
        return f"üßπ ƒê√£ x√≥a {completed_count} task ƒë√£ ho√†n th√†nh."

class PomodoroTimer:
    def __init__(self):
        self.is_running = False
        self.remaining_time = 0
        self.work_duration = 25 * 60  # 25 minutes
        self.break_duration = 5 * 60   # 5 minutes
        self.current_cycle = 0
        self.max_cycles = 4
        self.timer_thread = None
        
    def start_work(self, minutes: int = 25) -> str:
        """Start a work session."""
        if self.is_running:
            return "‚è∞ Timer ƒëang ch·∫°y. H√£y k·∫øt th√∫c ho·∫∑c t·∫°m d·ª´ng tr∆∞·ªõc."
        
        self.work_duration = minutes * 60
        self.remaining_time = self.work_duration
        self.is_running = True
        self.current_cycle += 1
        
        self.timer_thread = threading.Thread(target=self._run_timer, daemon=True)
        self.timer_thread.start()
        
        return f"üçÖ B·∫Øt ƒë·∫ßu l√†m vi·ªác {minutes} ph√∫t! (Chu k·ª≥ {self.current_cycle}/{self.max_cycles})"
    
    def start_break(self, minutes: int = 5) -> str:
        """Start a break session."""
        if self.is_running:
            return "‚è∞ Timer ƒëang ch·∫°y."
        
        self.break_duration = minutes * 60
        self.remaining_time = self.break_duration
        self.is_running = True
        
        self.timer_thread = threading.Thread(target=self._run_timer, daemon=True)
        self.timer_thread.start()
        
        return f"‚òï B·∫Øt ƒë·∫ßu ngh·ªâ ng∆°i {minutes} ph√∫t!"
    
    def _run_timer(self):
        """Run the timer in background."""
        while self.remaining_time > 0 and self.is_running:
            time.sleep(1)
            self.remaining_time -= 1
        
        if self.is_running:
            self.is_running = False
            if self.remaining_time == 0:
                # Timer completed
                if self.remaining_time == self.work_duration:
                    # Work session completed
                    if self.current_cycle >= self.max_cycles:
                        self._notify("üéâ Ho√†n th√†nh t·∫•t c·∫£ chu k·ª≥! Ngh·ªâ d√†i th√¥i!")
                    else:
                        self._notify("‚è∞ H·∫øt gi·ªù l√†m vi·ªác! ƒê·∫øn l√∫c ngh·ªâ ng∆°i.")
                else:
                    # Break completed
                    self._notify("‚è∞ H·∫øt gi·ªù ngh·ªâ! Quay l·∫°i l√†m vi·ªác th√¥i!")
    
    def _notify(self, message: str):
        """Send notification (could be enhanced with system notifications)."""
        print(f"NOTIFICATION: {message}")
    
    def stop(self) -> str:
        """Stop the current timer."""
        if not self.is_running:
            return "‚è∞ Kh√¥ng c√≥ timer n√†o ƒëang ch·∫°y."
        
        self.is_running = False
        if self.timer_thread:
            self.timer_thread.join(timeout=1)
        
        minutes = self.remaining_time // 60
        seconds = self.remaining_time % 60
        return f"‚èπÔ∏è ƒê√£ d·ª´ng timer. C√≤n l·∫°i: {minutes} ph√∫t {seconds} gi√¢y."
    
    def status(self) -> str:
        """Get current timer status."""
        if not self.is_running:
            return "‚è∞ Timer kh√¥ng ho·∫°t ƒë·ªông."
        
        minutes = self.remaining_time // 60
        seconds = self.remaining_time % 60
        
        if self.remaining_time == self.work_duration:
            session_type = "L√†m vi·ªác"
        else:
            session_type = "Ngh·ªâ ng∆°i"
        
        return f"‚è∞ {session_type}: {minutes:02d}:{seconds:02d} (Chu k·ª≥ {self.current_cycle}/{self.max_cycles})"

class Entertainment:
    def __init__(self):
        self.jokes = [
            "T·∫°i sao developer kh√¥ng th√≠ch thi√™n nhi√™n? V√¨ c√≥ qu√° nhi·ªÅu bugs!",
            "C√≥ 10 lo·∫°i ng∆∞·ªùi tr√™n th·∫ø gi·ªõi: nh·ªØng ng∆∞·ªùi hi·ªÉu nh·ªã ph√¢n v√† nh·ªØng ng∆∞·ªùi kh√¥ng.",
            "T·∫°i sao programmer lu√¥n nh·∫ßm l·∫´n gi·ªØa Halloween v√† Christmas? V√¨ Oct 31 == Dec 25!",
            "M·ªôt SQL query ƒëi v√†o qu√°n bar, ti·∫øp c·∫≠n hai b√†n v√† h·ªèi: 'T√¥i c√≥ th·ªÉ JOIN c√°c b·∫°n kh√¥ng?'",
            "T·∫°i sao Python programmer kh√¥ng c·∫ßn b·∫°n g√°i? V√¨ h·ªç ƒë√£ c√≥ import antigravity!"
        ]
        
        self.quotes = [
            "ƒê·ª´ng s·ª£ th·∫•t b·∫°i. H√£y s·ª£ vi·ªác kh√¥ng d√°m th·ª≠.",
            "Th√†nh c√¥ng kh√¥ng ph·∫£i l√† ƒë√≠ch ƒë·∫øn, m√† l√† h√†nh tr√¨nh.",
            "M·ªói ng√†y l√† m·ªôt c∆° h·ªôi m·ªõi ƒë·ªÉ tr·ªü n√™n t·ªët h∆°n.",
            "ƒêam m√™ + Ki√™n tr√¨ = Th√†nh c√¥ng",
            "H·ªçc, h·ªçc n·ªØa, h·ªçc m√£i - cho ƒë·∫øn khi bug ƒë∆∞·ª£c fix!"
        ]
    
    def tell_joke(self) -> str:
        """Tell a random joke."""
        return f"üòÇ {random.choice(self.jokes)}"
    
    def inspire(self) -> str:
        """Give an inspirational quote."""
        return f"üí´ {random.choice(self.quotes)}"
    
    def play_game(self, game_type: str = "") -> str:
        """Play a simple game."""
        games = {
            "coin": self._flip_coin,
            "dice": self._roll_dice,
            "number": self._random_number
        }
        
        if game_type in games:
            return games[game_type]()
        else:
            return "üéÆ Tr√≤ ch∆°i c√≥ s·∫µn: tung ƒë·ªìng xu, x√∫c x·∫Øc, s·ªë ng·∫´u nhi√™n"
    
    def _flip_coin(self) -> str:
        """Flip a coin."""
        result = "M·∫∑t ng·ª≠a" if random.random() > 0.5 else "M·∫∑t s·∫•p"
        return f"ü™ô Tung ƒë·ªìng xu: {result}"
    
    def _roll_dice(self) -> str:
        """Roll a dice."""
        result = random.randint(1, 6)
        return f"üé≤ X√∫c x·∫Øc: {result}"
    
    def _random_number(self) -> str:
        """Generate a random number."""
        result = random.randint(1, 100)
        return f"üî¢ S·ªë ng·∫´u nhi√™n: {result}"

# Global instances
task_manager = TaskManager()
pomodoro_timer = PomodoroTimer()
entertainment = Entertainment()

def work_assistant(command: str = None) -> str:
    """Main work assistant feature."""
    if not command:
        return get_help()
    
    tokens = command.lower().split()
    
    # Task management
    if any(word in tokens for word in ["task", "nhi·ªám v·ª•", "c√¥ng vi·ªác", "th√™m task"]):
        if "th√™m" in tokens or "add" in tokens:
            task_desc = command.split("th√™m")[-1].split("add")[-1].strip()
            if task_desc:
                priority = "high" if "quan tr·ªçng" in tokens else "medium"
                return task_manager.add_task(task_desc, priority)
        
        elif "xem" in tokens or "list" in tokens or "hi·ªÉn th·ªã" in tokens:
            show_all = "t·∫•t c·∫£" in tokens or "all" in tokens
            return task_manager.list_tasks(show_all)
        
        elif "ho√†n th√†nh" in tokens or "complete" in tokens:
            try:
                task_id = int(''.join(filter(str.isdigit, command)))
                return task_manager.complete_task(task_id)
            except:
                return "Vui l√≤ng cung c·∫•p ID task h·ª£p l·ªá."
        
        elif "x√≥a" in tokens or "clear" in tokens:
            return task_manager.clear_completed()
    
    # Pomodoro timer
    elif any(word in tokens for word in ["pomodoro", "timer", "h·∫πn gi·ªù", "l√†m vi·ªác"]):
        if "b·∫Øt ƒë·∫ßu" in tokens or "start" in tokens:
            if "ngh·ªâ" in tokens or "break" in tokens:
                minutes = 5
                if "ph√∫t" in tokens:
                    try:
                        minutes = int(''.join(filter(str.isdigit, command.split("ph√∫t")[0])))
                    except:
                        pass
                return pomodoro_timer.start_break(minutes)
            else:
                minutes = 25
                if "ph√∫t" in tokens:
                    try:
                        minutes = int(''.join(filter(str.isdigit, command.split("ph√∫t")[0])))
                    except:
                        pass
                return pomodoro_timer.start_work(minutes)
        
        elif "d·ª´ng" in tokens or "stop" in tokens:
            return pomodoro_timer.stop()
        
        elif "tr·∫°ng th√°i" in tokens or "status" in tokens:
            return pomodoro_timer.status()
    
    # Entertainment
    elif any(word in tokens for word in ["gi·∫£i tr√≠", "ƒë√πa", "joke", "c√¢u n√≥i", "tr√≤ ch∆°i"]):
        if "ƒë√πa" in tokens or "joke" in tokens:
            return entertainment.tell_joke()
        elif "c√¢u n√≥i" in tokens or "quote" in tokens:
            return entertainment.inspire()
        elif "tr√≤ ch∆°i" in tokens or "game" in tokens:
            if "xu" in tokens or "coin" in tokens:
                return entertainment.play_game("coin")
            elif "x√∫c x·∫Øc" in tokens or "dice" in tokens:
                return entertainment.play_game("dice")
            elif "s·ªë" in tokens or "number" in tokens:
                return entertainment.play_game("number")
            else:
                return entertainment.play_game()
    
    return get_help()

def get_help() -> str:
    """Get help information."""
    return """üéØ H·ªó tr·ª£ c√¥ng vi·ªác - H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:

üìã Qu·∫£n l√Ω Task:
‚Ä¢ "th√™m task [m√¥ t·∫£]" - Th√™m task m·ªõi
‚Ä¢ "xem task" - Xem task ƒëang ch·ªù
‚Ä¢ "xem t·∫•t c·∫£ task" - Xem c·∫£ task ƒë√£ ho√†n th√†nh
‚Ä¢ "ho√†n th√†nh task [id]" - ƒê√°nh d·∫•u task ho√†n th√†nh
‚Ä¢ "x√≥a task ƒë√£ ho√†n th√†nh" - X√≥a task ƒë√£ xong

üçÖ Pomodoro Timer:
‚Ä¢ "b·∫Øt ƒë·∫ßu l√†m vi·ªác [ph√∫t]" - B·∫Øt ƒë·∫ßu phi√™n l√†m vi·ªác
‚Ä¢ "b·∫Øt ƒë·∫ßu ngh·ªâ [ph√∫t]" - B·∫Øt ƒë·∫ßu ngh·ªâ ng∆°i
‚Ä¢ "d·ª´ng timer" - D·ª´ng timer hi·ªán t·∫°i
‚Ä¢ "tr·∫°ng th√°i timer" - Xem tr·∫°ng th√°i timer

üéÆ Gi·∫£i tr√≠:
‚Ä¢ "k·ªÉ chuy·ªán ƒë√πa" - K·ªÉ chuy·ªán c∆∞·ªùi
‚Ä¢ "c√¢u n√≥i truy·ªÅn c·∫£m h·ª©ng" - C√¢u n√≥i hay
‚Ä¢ "ch∆°i game" - Tr√≤ ch∆°i ƒë∆°n gi·∫£n

H√£y th·ª≠ m·ªôt trong c√°c l·ªánh tr√™n!"""

# Keywords and patterns for feature detection
keywords = [
    "task", "nhi·ªám v·ª•", "c√¥ng vi·ªác", "pomodoro", "timer", 
    "h·∫πn gi·ªù", "gi·∫£i tr√≠", "ƒë√πa", "tr√≤ ch∆°i", "game"
]

patterns = [
    "th√™m task",
    "xem task",
    "b·∫Øt ƒë·∫ßu l√†m vi·ªác",
    "b·∫Øt ƒë·∫ßu ngh·ªâ ng∆°i",
    "k·ªÉ chuy·ªán ƒë√πa",
    "ch∆°i game"
]
